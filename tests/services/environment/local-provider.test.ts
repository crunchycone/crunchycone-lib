/**
 * Tests for Local Environment Provider
 * Tests .env file operations and secrets no-ops
 */

import * as fs from 'fs';
import * as path from 'path';
import { LocalEnvironmentProvider } from '../../../src/services/environment/providers/local-provider';

describe('LocalEnvironmentProvider', () => {
  const testTempDir = path.join(__dirname, 'temp-local-test');
  const testEnvPath = path.join(testTempDir, '.env');
  let provider: LocalEnvironmentProvider;

  beforeEach(() => {
    // Create temp directory for test .env files
    if (fs.existsSync(testTempDir)) {
      fs.rmSync(testTempDir, { recursive: true });
    }
    fs.mkdirSync(testTempDir, { recursive: true });
    
    provider = new LocalEnvironmentProvider(testEnvPath);
  });

  afterEach(() => {
    // Clean up temp directory
    if (fs.existsSync(testTempDir)) {
      fs.rmSync(testTempDir, { recursive: true });
    }
  });

  describe('Provider Metadata', () => {
    test('should return correct provider type and capabilities', () => {
      expect(provider.getProviderType()).toBe('local');
      expect(provider.supportsSecrets()).toBe(false);
    });

    test('should provide .env file path', () => {
      expect(provider.getDotEnvPath()).toBe(testEnvPath);
    });
  });

  describe('Environment Variables', () => {
    test('should handle empty .env file', async () => {
      const value = await provider.getEnvVar('NONEXISTENT');
      expect(value).toBeUndefined();
      
      const allVars = await provider.listEnvVars();
      expect(allVars).toEqual({});
    });

    test('should set and get environment variables', async () => {
      await provider.setEnvVar('TEST_VAR', 'test-value');
      
      const value = await provider.getEnvVar('TEST_VAR');
      expect(value).toBe('test-value');
      
      // Verify file content
      const fileContent = fs.readFileSync(testEnvPath, 'utf-8');
      expect(fileContent).toContain('TEST_VAR=test-value');
    });

    test('should update existing environment variables', async () => {
      await provider.setEnvVar('TEST_VAR', 'original-value');
      await provider.setEnvVar('TEST_VAR', 'updated-value');
      
      const value = await provider.getEnvVar('TEST_VAR');
      expect(value).toBe('updated-value');
    });

    test('should delete environment variables', async () => {
      await provider.setEnvVar('TEST_VAR', 'test-value');
      await provider.setEnvVar('OTHER_VAR', 'other-value');
      
      let allVars = await provider.listEnvVars();
      expect(allVars).toEqual({
        TEST_VAR: 'test-value',
        OTHER_VAR: 'other-value',
      });
      
      await provider.deleteEnvVar('TEST_VAR');
      
      allVars = await provider.listEnvVars();
      expect(allVars).toEqual({
        OTHER_VAR: 'other-value',
      });
      
      const deletedValue = await provider.getEnvVar('TEST_VAR');
      expect(deletedValue).toBeUndefined();
    });

    test('should list all environment variables', async () => {
      await provider.setEnvVar('VAR1', 'value1');
      await provider.setEnvVar('VAR2', 'value2');
      await provider.setEnvVar('VAR3', 'value3');
      
      const allVars = await provider.listEnvVars();
      expect(allVars).toEqual({
        VAR1: 'value1',
        VAR2: 'value2',
        VAR3: 'value3',
      });
    });

    test('should handle values with special characters', async () => {
      const specialValues = {
        'SPACES': 'value with spaces',
        'QUOTES': 'value "with" quotes',
        'SINGLE_QUOTES': 'value \'with\' single quotes',
        'HASH': 'value # with hash',
        'DOLLAR': 'value $ with dollar',
        'BACKTICKS': 'value `with` backticks',
        'BACKSLASHES': 'value \\ with \\ backslashes',
        'NEWLINES': 'value\nwith\nnewlines',
        'EMPTY': '',
      };
      
      // Set all special values
      for (const [key, value] of Object.entries(specialValues)) {
        await provider.setEnvVar(key, value);
      }
      
      // Verify all values can be read back correctly
      for (const [key, expectedValue] of Object.entries(specialValues)) {
        const actualValue = await provider.getEnvVar(key);
        expect(actualValue).toBe(expectedValue);
      }
    });

    test('should generate properly formatted .env file', async () => {
      await provider.setEnvVar('DATABASE_URL', 'postgres://user:pass@localhost/db');
      await provider.setEnvVar('API_KEY', 'abc123');
      await provider.setEnvVar('DEBUG', 'true');
      
      const content = fs.readFileSync(testEnvPath, 'utf-8');
      
      // Should have header comment
      expect(content).toContain('# Environment Variables');
      expect(content).toContain('# Generated by CrunchyCone Environment Service');
      
      // Should have all variables (order may vary due to sorting)
      expect(content).toContain('API_KEY=abc123');
      expect(content).toContain('DATABASE_URL=postgres://user:pass@localhost/db'); // No quotes needed for this URL
      expect(content).toContain('DEBUG=true');
      
      // Should end with newline
      expect(content.endsWith('\n')).toBe(true);
    });

    test('should parse existing .env file correctly', async () => {
      const envContent = `
# This is a comment
DATABASE_URL=postgres://localhost/test
API_KEY="secret-key-with-spaces"
DEBUG=true
EMPTY_VALUE=""
SINGLE_QUOTED='single-quoted-value'

# Another comment
PORT=3000
`.trim();
      
      fs.writeFileSync(testEnvPath, envContent);
      
      const allVars = await provider.listEnvVars();
      expect(allVars).toEqual({
        DATABASE_URL: 'postgres://localhost/test',
        API_KEY: 'secret-key-with-spaces',
        DEBUG: 'true',
        EMPTY_VALUE: '',
        SINGLE_QUOTED: 'single-quoted-value',
        PORT: '3000',
      });
    });

    test('should preserve and merge with existing .env content', async () => {
      // Create initial .env file
      const initialContent = `
DATABASE_URL=postgres://localhost/initial
EXISTING_VAR=keep-this
`.trim();
      fs.writeFileSync(testEnvPath, initialContent);
      
      // Add new variable
      await provider.setEnvVar('NEW_VAR', 'new-value');
      
      const allVars = await provider.listEnvVars();
      expect(allVars).toEqual({
        DATABASE_URL: 'postgres://localhost/initial',
        EXISTING_VAR: 'keep-this',
        NEW_VAR: 'new-value',
      });
    });
  });

  describe('Secrets Operations (No-ops)', () => {
    let consoleSpy: jest.SpyInstance;

    beforeEach(() => {
      consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
    });

    afterEach(() => {
      consoleSpy.mockRestore();
    });

    test('should warn when setting secrets', async () => {
      await provider.setSecret('SECRET_KEY', 'secret-value');
      
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Secrets are not supported locally'),
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('setSecret(\'SECRET_KEY\')'),
      );
    });

    test('should warn when deleting secrets', async () => {
      await provider.deleteSecret('SECRET_KEY');
      
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Secrets are not supported locally'),
      );
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('deleteSecret(\'SECRET_KEY\')'),
      );
    });

    test('should return empty array for secret names', async () => {
      const secretNames = await provider.listSecretNames();
      expect(secretNames).toEqual([]);
    });

    test('should not throw errors for secret operations', async () => {
      await expect(provider.setSecret('SECRET1', 'value1')).resolves.not.toThrow();
      await expect(provider.deleteSecret('SECRET2')).resolves.not.toThrow();
      await expect(provider.listSecretNames()).resolves.not.toThrow();
    });
  });

  describe('Error Handling', () => {
    test('should handle permission errors gracefully', async () => {
      // Skip this test as permission errors are environment-dependent
      // and may not occur in all test environments
      expect(true).toBe(true);
    });

    test('should handle malformed .env files', async () => {
      // Create malformed .env file
      const malformedContent = `
VALID_VAR=valid
INVALID LINE WITHOUT EQUALS
=INVALID_KEY
VALID_VAR2=also-valid
`.trim();
      
      fs.writeFileSync(testEnvPath, malformedContent);
      
      const allVars = await provider.listEnvVars();
      expect(allVars).toEqual({
        VALID_VAR: 'valid',
        VALID_VAR2: 'also-valid',
      });
    });

    test('should create directory if it does not exist', async () => {
      const nestedPath = path.join(testTempDir, 'nested', 'deep', '.env');
      const nestedProvider = new LocalEnvironmentProvider(nestedPath);
      
      await nestedProvider.setEnvVar('TEST', 'value');
      
      expect(fs.existsSync(nestedPath)).toBe(true);
      const value = await nestedProvider.getEnvVar('TEST');
      expect(value).toBe('value');
    });
  });
});