/**
 * Local Environment Provider
 * Manages environment variables via .env files
 * Secrets operations are no-ops (not supported locally)
 */

import * as fs from 'fs';
import * as path from 'path';
import { EnvironmentProvider, ProviderType } from '../types';

export class LocalEnvironmentProvider implements EnvironmentProvider {
  private dotEnvPath: string;

  constructor(dotEnvPath?: string) {
    this.dotEnvPath = dotEnvPath || path.join(process.cwd(), '.env');
  }

  getProviderType(): ProviderType {
    return 'local';
  }

  supportsSecrets(): boolean {
    return false;
  }

  // Environment Variables Implementation

  async getEnvVar(key: string): Promise<string | undefined> {
    const envVars = await this.loadEnvFile();
    return envVars[key];
  }

  async setEnvVar(key: string, value: string): Promise<void> {
    const envVars = await this.loadEnvFile();
    envVars[key] = value;
    await this.saveEnvFile(envVars);
  }

  async deleteEnvVar(key: string): Promise<void> {
    const envVars = await this.loadEnvFile();
    delete envVars[key];
    await this.saveEnvFile(envVars);
  }

  async listEnvVars(): Promise<Record<string, string>> {
    return await this.loadEnvFile();
  }

  // Secrets Implementation (No-ops for local provider)

  async setSecret(key: string, _value: string): Promise<void> {
    // No-op: Secrets are not supported in local environment
    console.warn(`LocalEnvironmentProvider: Secrets are not supported locally. Ignoring setSecret('${key}')`);
  }

  async deleteSecret(key: string): Promise<void> {
    // No-op: Secrets are not supported in local environment
    console.warn(`LocalEnvironmentProvider: Secrets are not supported locally. Ignoring deleteSecret('${key}')`);
  }

  async listSecretNames(): Promise<string[]> {
    // No-op: Secrets are not supported in local environment
    return [];
  }

  // Private helpers for .env file management

  private async loadEnvFile(): Promise<Record<string, string>> {
    try {
      if (!fs.existsSync(this.dotEnvPath)) {
        return {};
      }

      const content = await fs.promises.readFile(this.dotEnvPath, 'utf-8');
      return this.parseEnvContent(content);
    } catch (error) {
      throw new Error(`Failed to read .env file at ${this.dotEnvPath}: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private async saveEnvFile(envVars: Record<string, string>): Promise<void> {
    try {
      const content = this.serializeEnvContent(envVars);
      
      // Ensure directory exists
      const dir = path.dirname(this.dotEnvPath);
      if (!fs.existsSync(dir)) {
        await fs.promises.mkdir(dir, { recursive: true });
      }

      await fs.promises.writeFile(this.dotEnvPath, content, 'utf-8');
    } catch (error) {
      throw new Error(`Failed to write .env file at ${this.dotEnvPath}: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private parseEnvContent(content: string): Record<string, string> {
    const envVars: Record<string, string> = {};
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      
      // Skip empty lines and comments
      if (!trimmed || trimmed.startsWith('#')) {
        continue;
      }

      // Handle key=value pairs
      const equalIndex = trimmed.indexOf('=');
      if (equalIndex > 0) {
        const key = trimmed.substring(0, equalIndex).trim();
        const value = trimmed.substring(equalIndex + 1).trim();
        
        // Remove quotes if present
        const unquotedValue = this.unquoteValue(value);
        envVars[key] = unquotedValue;
      }
    }

    return envVars;
  }

  private serializeEnvContent(envVars: Record<string, string>): string {
    const lines: string[] = [];
    
    // Add header comment
    lines.push('# Environment Variables');
    lines.push('# Generated by CrunchyCone Environment Service');
    lines.push('');

    // Sort keys for consistent output
    const sortedKeys = Object.keys(envVars).sort();
    
    for (const key of sortedKeys) {
      const value = envVars[key];
      const quotedValue = this.quoteValue(value);
      lines.push(`${key}=${quotedValue}`);
    }

    return lines.join('\n') + '\n';
  }

  private unquoteValue(value: string): string {
    // Remove surrounding quotes (single or double) and unescape
    if (value.startsWith('"') && value.endsWith('"')) {
      const unquoted = value.slice(1, -1);
      // Unescape double quotes and common escape sequences
      return unquoted
        .replace(/\\n/g, '\n')
        .replace(/\\r/g, '\r')
        .replace(/\\t/g, '\t')
        .replace(/\\"/g, '"')
        .replace(/\\\\/g, '\\'); // This must be last to avoid double unescaping
    }
    if (value.startsWith('\'') && value.endsWith('\'')) {
      return value.slice(1, -1);
    }
    return value;
  }

  private quoteValue(value: string): string {
    // Quote value if it contains spaces, special characters, or is empty
    if (value === '' || 
        /[\s#"'\\$`]/.test(value) || 
        value.includes('\n') || 
        value.includes('\r')) {
      // Escape common escape sequences and double quotes
      const escaped = value
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\t/g, '\\t');
      return `"${escaped}"`;
    }
    return value;
  }

  // Utility method to get the current .env file path
  getDotEnvPath(): string {
    return this.dotEnvPath;
  }
}